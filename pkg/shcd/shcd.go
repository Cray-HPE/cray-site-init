/*
 *
 *  MIT License
 *
 *  (C) Copyright 2022 Hewlett Packard Enterprise Development LP
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included
 *  in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *  OTHER DEALINGS IN THE SOFTWARE.
 *
 */

package shcd

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"regexp"
	"strconv"
	"strings"
	"unicode/utf8"

	xnames "github.com/Cray-HPE/hms-xname/xnames"
)

// The Shcd type represents the entire machine-readable SHCD inside a go struct
type Shcd struct {
	Architecture string `json:"architecture"`
	CanuVersion  string `json:"canu_version"`
	ShcdFile     string `json:"shcd_file"`
	UpdatedAt    string `json:"updated_at"`
	Topology     []ID   `json:"topology"`
}

func NewShcd(shcdFilePath string) (*Shcd, error) {
	data, err := ioutil.ReadFile(shcdFilePath)
	if err != nil {
		return &Shcd{}, err
	}
	shcd, err := ParseSHCD(data)
	if err != nil {
		return &Shcd{}, err
	}
	return &shcd, nil
}

// ParseSHCD accepts a machine-readable SHCD and produces an Shcd object, which can be used throughout csi
// It is the golang and csi equivalent of the shcd.json file generated by canu
func ParseSHCD(f []byte) (Shcd, error) {
	var shcd Shcd
	err := json.Unmarshal(f, &shcd)
	if err != nil {
		return shcd, err
	}
	return shcd, nil
}

// FilterByType loop over the topology and return all items found in a give type.
func FilterByType(topology []ID, idType string) []ID {
	items := []ID{}
	for i := range topology {
		if topology[i].Type == idType {
			items = append(items, topology[i])
		}
	}
	return items
}

// The ID type represents all of the information needed for
type ID struct {
	Architecture string   `json:"architecture"`
	CommonName   string   `json:"common_name"`
	ID           int      `json:"id"`
	Location     Location `json:"location"`
	Model        string   `json:"model"`
	Ports        []Port   `json:"ports"`
	Type         string   `json:"type"`
	Vendor       string   `json:"vendor"`
}

// GenerateXname crafts and prints the xname of a give ID type in the SHCD
func (id ID) GenerateXname() (xn string) {
	// Schema decoder ring:
	// 		cabinet = rack
	// 		chassis = defaults to 0  River: c0, Mountain/Hill: this is the CMM number
	// 		slot = elevation
	// 		space =
	// Each xname has a different structure depending on what the device is
	// This is just a big string of if/else conditionals to determine this
	// At present, this is limited to checking the nodes needed in switch_metadata.csv
	// Single node chassis bB is always 0
	bmcOrdinal := 0
	// If it's a CDU switch
	if strings.HasPrefix(id.CommonName, "sw-cdu-") {
		// We need just the number
		i := strings.TrimPrefix(id.CommonName, "sw-cdu-")
		slot, err := strconv.Atoi(i)
		if err != nil {
			log.Fatalln(err)
		}
		x := xnames.CDUMgmtSwitch{
			CDU:           0,
			CDUMgmtSwitch: slot,
		}
		xn = x.String()
		// LeafBMC switches have their own needs
	} else if strings.HasPrefix(id.CommonName, "sw-leaf-bmc-") {
		// Get the just number of the elevation
		i := strings.TrimPrefix(id.Location.Elevation, "u")
		// Convert it to an int
		slot, err := strconv.Atoi(i)
		if err != nil {
			log.Fatalln(err)
		}
		// Get the rack as a string
		cabString := id.Location.Rack
		// Strip the "x"
		_, cabNum := utf8.DecodeRuneInString(cabString)
		// Convert to an int
		cabinet, err := strconv.Atoi(cabString[cabNum:])
		if err != nil {
			log.Fatalln(err)
		}
		// Create the xname
		// Chassis defaults to 0 in most cases
		// xXcCwW
		x := xnames.MgmtSwitch{
			Cabinet:    cabinet, // X: 0-999
			Chassis:    0,       // C: 0-7
			MgmtSwitch: slot,    // W: 1-48
		}
		// Convert it to a string
		xn = x.String()
		// Spine switches
	} else if strings.HasPrefix(id.CommonName, "sw-spine") {
		// Convert the rack to a string
		cabString := id.Location.Rack
		// Strip the "x"
		_, cabNum := utf8.DecodeRuneInString(cabString)
		// Convert to an int
		cabinet, err := strconv.Atoi(cabString[cabNum:])
		if err != nil {
			log.Fatalln(err)
		}
		// Strip the u
		i := strings.TrimPrefix(id.Location.Elevation, "u")
		// Convert it to an int
		slot, err := strconv.Atoi(i)
		if err != nil {
			log.Fatalln(err)
		}
		// space always 1 unless vendor is mellanox
		space := 1
		if id.Vendor == "mellanox" {
			i := strings.TrimPrefix(id.CommonName, "sw-spine-")
			space, err = strconv.Atoi(i)
			if err != nil {
				log.Fatalln(err)
			}
		}
		// Create the xname
		// Chassis and Space default to 0 and 1 in most cases
		// xXcChHsS
		x := xnames.MgmtHLSwitch{
			Cabinet:               cabinet, // X: 0-999
			Chassis:               0,       // C: 0-7
			MgmtHLSwitchEnclosure: slot,    // H: 1-48
			MgmtHLSwitch:          space,   // S: 1-4
		}
		xn = x.String()
	} else if strings.HasPrefix(id.CommonName, "sw-leaf") ||
		strings.HasPrefix(id.CommonName, "sw-edge") {
		// Convert the rack to a string
		cabString := id.Location.Rack
		// Strip the "x"
		_, cabNum := utf8.DecodeRuneInString(cabString)
		// Convert to an int
		cabinet, err := strconv.Atoi(cabString[cabNum:])
		if err != nil {
			log.Fatalln(err)
		}
		// Strip the u
		i := strings.TrimPrefix(id.Location.Elevation, "u")
		// Convert it to an int
		slot, err := strconv.Atoi(i)
		if err != nil {
			log.Fatalln(err)
		}
		// Create the xname
		// Chassis and Space default to 0 and 1 in most cases
		// xXcChHsS
		x := xnames.MgmtHLSwitch{
			Cabinet:               cabinet, // X: 0-999
			Chassis:               0,       // C: 0-7
			MgmtHLSwitchEnclosure: slot,    // H: 1-48
			MgmtHLSwitch:          1,       // S: 1-4
		}
		xn = x.String()
	} else if strings.HasPrefix(id.CommonName, "ncn-") {
		// Convert the rack to a string
		cabString := id.Location.Rack
		// Strip the "x"
		_, cabNum := utf8.DecodeRuneInString(cabString)
		// Convert to an int
		cabinet, err := strconv.Atoi(cabString[cabNum:])
		if err != nil {
			log.Fatalln(err)
		}
		// Strip the u
		i := strings.TrimPrefix(id.Location.Elevation, "u")
		// Check if this is a dense 4 node chassis or dual node chassis as additional logic is needed for these to find the slot number
		if strings.HasSuffix(i, "L") || strings.HasSuffix(i, "R") {
			// Dense 4 node chassis - Gigabyte or Intel chassis --
			// The BMC ordinal for the nodes BMC is derived from the NID of the node, by applying a modulo of 4 plus 1
			if id.Vendor == "gigabyte" || id.Vendor == "intel" {
				i = strings.TrimSuffix(i, "L")
				i = strings.TrimSuffix(i, "R")
				slot, err := strconv.Atoi(i)
				if err != nil {
					log.Fatalln(err)
				}
				bmcOrdinal = (slot % 4) + 1
				// Dual node chassis - Apollo 6500 XL645D -- L == b1, R == b2
			} else if id.Vendor == "hpe" {
				if strings.HasSuffix(i, "L") {
					bmcOrdinal = 1
				} else if strings.HasSuffix(i, "R") {
					bmcOrdinal = 2
				}
			}
		}
		// Convert it to an int
		slot, err := strconv.Atoi(i)
		if err != nil {
			log.Fatalln(err)
		}
		// xCcCsSbBnN
		x := xnames.Node{
			Cabinet:       cabinet,    // X: 0-999
			Chassis:       0,          // C: 0-7
			ComputeModule: slot,       // S: 1-63
			NodeBMC:       bmcOrdinal, // B: 0-1 - TODO the HSOS document is wrong here. as we do actually use greater than 1
			// For all river hardware the value of N should be always be 0
			Node: 0, // N: 0-7
		}
		xn = x.String()
	}
	// Return the crafted xname
	return xn
}

// GenerateNCNRoleSubrole generates the appropriate role and subrole based on the ncn-* name
func (id ID) GenerateNCNRoleSubrole() (r string, sr string) {
	if strings.HasPrefix(id.CommonName, "ncn-s") {
		r = "Management"
		sr = "Storage"
	} else if strings.HasPrefix(id.CommonName, "ncn-w") {
		r = "Management"
		sr = "Worker"
	} else if strings.HasPrefix(id.CommonName, "ncn-m") {
		r = "Management"
		sr = "Master"
	}
	// Return the role and subrole ncn_metadata.csv is expecting
	return r, sr
}

// GenerateSwitchType crafts and prints the switch types that switch_metadata.csv expects
func (id ID) GenerateSwitchType() (st string) {
	// The switch type in switch_metadata.csv differs from the types in the SHCD
	// These conditionals just adjust for the names we expect in that file
	if strings.Contains(id.Architecture, "bmc") {
		st = "LeafBMC"
	} else if strings.Contains(id.Architecture, "spine") {
		st = "Spine"
	} else if strings.Contains(id.Architecture, "river_ncn_leaf") {
		st = "Leaf"
	} else if strings.Contains(id.CommonName, "cdu") {
		st = "CDU"
	} else if strings.Contains(id.CommonName, "edge") {
		st = "Edge"
	}
	// Return the switch type switch_metadata.csv is expecting
	return st
}

// GenerateHMNSourceName crafts and prints the switch types that hmn_connections.json expects
func (id ID) GenerateHMNSourceName() string {
	var src string
	// The Source in hmn_connections.json differs from the common_name in the paddle file
	// These conditionals just adjust for the names we expect in that file
	// Get the just number of the elevation
	r := regexp.MustCompile(`\d{2}$`)
	// matches contains the numbers found in the common name
	matches := r.FindAllString(id.CommonName, -1)
	if strings.HasPrefix(id.CommonName, "ncn-m") {
		src = "mn" + matches[0]
	} else if strings.HasPrefix(id.CommonName, "ncn-w") {
		src = "wn" + matches[0]
	} else if strings.HasPrefix(id.CommonName, "ncn-s") {
		src = "sn" + matches[0]
	} else if strings.HasPrefix(id.CommonName, "uan") {
		src = "uan" + matches[0]
	} else if strings.HasPrefix(id.CommonName, "pdu-x3000-") {
		r := regexp.MustCompile(`\d{1}$`)
		matches := r.FindAllString(id.CommonName, -1)
		src = "x3000p" + matches[0]
	} else if strings.HasPrefix(id.CommonName, "cn") {
		src = "cn" + matches[0]
	} else if strings.HasPrefix(id.CommonName, "sw-hsn-") {
		src = "sw-hsn" + matches[0]
	} else {
		src = id.CommonName
	}
	return src
}

// The Port type defines where things are plugged in
type Port struct {
	DestNodeID int    `json:"destination_node_id"`
	DestPort   int    `json:"destination_port"`
	DestSlot   string `json:"destination_slot"`
	Port       int    `json:"port"`
	Slot       string `json:"slot"`
	Speed      int    `json:"speed"`
}

// The Location type defines where the server physically exists in the datacenter.
type Location struct {
	Elevation string `json:"elevation"`
	Rack      string `json:"rack"`
}

// HMNConnections type is the go equivalent structure of hmn_connections.json
type HMNConnections []HMNComponent

// HMNComponent is an individual component in the HMNConnections slice
type HMNComponent struct {
	Source              string `json:"Source"`
	SourceRack          string `json:"SourceRack"`
	SourceLocation      string `json:"SourceLocation"`
	SourceParent        string `json:"SourceParent,omitempty"`
	SourceSubLocation   string `json:"SourceSubLocation,omitempty"`
	DestinationRack     string `json:"DestinationRack"`
	DestinationLocation string `json:"DestinationLocation"`
	DestinationPort     string `json:"DestinationPort"`
}

// NCNMetadata type is the go equivalent structure of ncn_metadata.csv
type NCNMetadata []NcnMacs

// NcnMacs is a row in ncn_metadata.csv
type NcnMacs struct {
	Xname        string
	Role         string
	Subrole      string
	BmcMac       string
	BootstrapMac string
	Bond0Mac0    string
	Bond0Mac1    string
}

// SwitchMetadata type is the go equivalent structure of switch_metadata.csv
type SwitchMetadata []Switch

// Switch is a row in switch_metadata.csv
type Switch struct {
	Xname string
	Type  string
	Brand string
}
