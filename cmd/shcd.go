/*
Copyright 2021 Hewlett Packard Enterprise Development LP
*/

package cmd

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"github.com/xeipuuv/gojsonschema"
)

const schemaFile = "internal/files/shcd-schema.json"
const hmn_connections = "hmn_connections.json"
const switch_metadata = "switch_metadata.csv"

var createHMN, createSM bool

// initCmd represents the init command
var shcdCmd = &cobra.Command{
	Use:   "shcd FILEPATH",
	Short: "Generates hmn_connections.json and switch_metadata.csv from an SHCD JSON file",
	Long: `Generates hmn_connections.json and switch_metadata.csv from an SHCD JSON file.

	It accepts only a valid JSON file, generated by 'canu', which is creates a machine-
	readable format understood by csi.  It is checked against a pre-defined schema and
	if it adhere's to it, it generates the necessary seed files.
	`,
	Args: cobra.MinimumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		v := viper.GetViper()
		v.BindPFlags(cmd.Flags())

		// Validate the file passed against the pre-defined schema
		validSHCD, err := ValidateSchema(args[0], schemaFile)

		if err != nil {
			log.Fatalf(err.Error())
		}

		// If the file meets the schema criteria
		if validSHCD {

			// Open the file since we know it is valid
			shcdFile, err := ioutil.ReadFile(args[0])

			if err != nil {
				log.Fatalf(err.Error())
			}

			// Parse the JSON and return an Shcd object
			// s, err := ParseSHCD(shcdFile)

			if err != nil {
				log.Fatalf(err.Error())
			}

			// Pretty print the structured data
			// shcd, err := json.MarshalIndent(&s, "", " ")

			if err != nil {
				log.Fatalf(err.Error())
			}

			if v.IsSet("hmn-connections") {

				createHMNSeed(shcdFile, hmn_connections)

			}

			if v.IsSet("switch-metadata") {

				createSwitchSeed(shcdFile, switch_metadata)

			}

			// TODO: instead of printing the entire thing, create some of the seed file automatically
			// fmt.Println(string(shcd))

		} else {

			log.Printf("- %s\n", err)

			if err != nil {
				log.Fatalf(err.Error())
			}

		}
	},
}

func init() {
	shcdCmd.DisableAutoGenTag = true
	shcdCmd.Flags().SortFlags = true
	shcdCmd.Flags().BoolVarP(&createHMN, "hmn-connections", "H", false, "Generate the hmn_connections.json file")
	shcdCmd.Flags().BoolVarP(&createSM, "switch-metadata", "S", false, "Generate the switch_metadata.csv file")
}

// The Shcd type represents the entire machine-readable SHCD inside a go struct
type Shcd []Id

// The Id type represents all of the information needed for
type Id struct {
	Architecture string   `json:"architecture"`
	CommonName   string   `json:"common_name"`
	ID           int      `json:"id"`
	Location     Location `json:"location"`
	Model        string   `json:"model"`
	Ports        []Port   `json:"ports"`
	Type         string   `json:"type"`
	Vendor       string   `json:"vendor"`
}

// The Port type defines where things are plugged in
type Port struct {
	DestNodeID int    `json:"destination_node_id"`
	DestPort   int    `json:"destination_port"`
	DestSlot   string `json:"destination_slot"`
	Port       int    `json:"port"`
	Slot       string `json:"slot"`
	Speed      int    `json:"speed"`
}

type Location struct {
	Elevation string `json:"elevation"`
	Rack      string `json:"rack"`
}

// HMNConnections type is the go equivalent structure of hmn_connections.json
type HMNConnections []HMNComponent

// HMNComponent is an individual component in the HMNConnections slice
type HMNComponent struct {
	Source              string `json:"Source"`
	SourceRack          string `json:"SourceRack"`
	SourceLocation      string `json:"SourceLocation"`
	SourceParent        string `json:"SourceParent,omitempty"`
	SourceSubLocation   string `json:"SourceSubLocation,omitempty"`
	DestinationRack     string `json:"DestinationRack"`
	DestinationLocation string `json:"DestinationLocation"`
	DestinationPort     string `json:"DestinationPort"`
}

// SwitchMetadata type is the go equivalent structure of switch_metadata.csv
type SwitchMetadata []Switch

// Switch is a row in switch_metadata.csv
type Switch struct {
	Xname string
	Type  string
	Brand string
}

// createSwitchSeed creates switch_metadata.csv using information from the shcd
func createSwitchSeed(s []byte, f string) {
	var shcd Shcd
	var switches SwitchMetadata

	// unmarshall it
	err := json.Unmarshal(s, &shcd)

	if err != nil {
		fmt.Println("error:", err)
	}

	// For each entry in the SHCD
	for i := range shcd {

		// Create a new Switch type and append it to the SwitchMetadata slice
		switches = append(switches, Switch{
			Xname: shcd[i].Location.Rack,
			Type:  shcd[i].Type,
			Brand: shcd[i].Vendor,
		})

	}

	// When writing to csv, the first row should be the headers
	headers := []string{"Switch Xname", "Type", "Brand"}

	// Set up the records we need to write to the file
	// To begin, this contains the headers
	records := [][]string{headers}

	// Then create a new slice with the three pieces of information needed
	for _, v := range switches {
		row := []string{v.Xname, v.Type, v.Brand}
		// Append it to the records slice under the column headers
		records = append(records, row)
	}

	// Create the file object
	sm, err := os.Create(switch_metadata)

	if err != nil {
		log.Fatalln(err)
	}

	defer sm.Close()

	// Create a writer, which will write the data to the file
	writer := csv.NewWriter(sm)

	defer writer.Flush()

	if err != nil {
		log.Fatalln(err)
	}

	// For each item in the records slice
	for _, v := range records {
		// Write it to the csv file
		if err := writer.Write(v); err != nil {
			log.Fatalln(err)
		}
	}

	// Let the user know the file was created
	log.Printf("Created %v from SHCD data\n", switch_metadata)
}

// createHMNSeed creates hmn_connections.json using information from the shcd
// Really, creating this file is a pain, but it's the only way to get the data without revamping 'config init'
// This way, we can have the computer generate the file, and then the user can use it as normal with 'config init'
func createHMNSeed(s []byte, f string) {

	var shcd Shcd
	var hmn HMNConnections

	// unmarshall the bytes received into the Shcd type
	err := json.Unmarshal(s, &shcd)

	if err != nil {
		fmt.Println("error:", err)
	}

	// For each entry in the shcd
	for i := range shcd {

		// instantiate a new HMNComponent
		hmnConnection := HMNComponent{}

		// This just aligns the names to better match existing hmn_connections.json's
		// The SHCD and shcd.json all use different names, so why should csi be any different?
		// nodeName := unNormalizeSemiStandardShcdNonName(shcd[i].CommonName)

		// Setting the source name, source rack, source location, is pretty straightforward here
		hmnConnection.Source = shcd[i].CommonName
		hmnConnection.SourceRack = shcd[i].Location.Rack
		hmnConnection.SourceLocation = shcd[i].Location.Elevation

		// Now it starts to get more complex.
		// shcd.json has an array of ports that the device is connected to
		// loop through the ports and find the destination id, which can be used
		// to find the destination info
		for p := range shcd[i].Ports {
			// get the id of the destination node, so it can be easily used an an index
			destId := shcd[i].Ports[p].DestNodeID
			// Special to this hmn_connections.json file, we need this SubRack/dense node stuff
			// if the node is a dense compute node--indiciated by L or R in the location,
			// we need to add the SourceSubLocation and SourceParent
			// There should be a row in the shcd that has the SubRack name, which
			// shares the same u location as the entries with the L or R in the location
			if strings.HasSuffix(shcd[i].Location.Elevation, "L") || strings.HasSuffix(shcd[i].Location.Elevation, "R") {
				// hmnConnection.SourceSubLocation = shcd[i].Location.Rack
				hmnConnection.SourceParent = "FIXME INSERT SUBRACK HERE"
				// FIXME: remove above and uncomment below when we have a way to get the subrack name
				// hmnConnection.SourceParent = fmt.Sprint(shcd[destId].CommonName)
			}

			// Now use the destId again to set the destination info
			hmnConnection.DestinationRack = shcd[destId].Location.Rack
			hmnConnection.DestinationLocation = shcd[destId].Location.Elevation
			hmnConnection.DestinationPort = fmt.Sprint("j", shcd[i].Ports[p].DestPort)
		}

		// finally, append the created HMNComponent to the HMNConnections slice
		// This slice will be what is written to the file as hmn_connections.json
		hmn = append(hmn, hmnConnection)
	}

	// Indent the file for better human-readability
	file, _ := json.MarshalIndent(hmn, "", " ")

	// Write the file to disk
	_ = ioutil.WriteFile(hmn_connections, file, 0644)

	log.Printf("Created %v from SHCD data\n", hmn_connections)

}

// ValidateSchema compares a JSON file to the defined schema file
func ValidateSchema(f string, s string) (bool, error) {
	// First validate the file passed in conforms to the schema
	schema := "file://" + s
	schemaLoader := gojsonschema.NewReferenceLoader(schema)
	jsonFile := "file://" + f
	documentLoader := gojsonschema.NewReferenceLoader(jsonFile)

	result, err := gojsonschema.Validate(schemaLoader, documentLoader)

	if err != nil {
		return false, fmt.Errorf("%s", err)
	}

	// If the json passed in does not meet the schema requirements, error
	if !result.Valid() {

		for _, desc := range result.Errors() {
			return false, fmt.Errorf("SHCD schema error: %s", desc)
		}

	}

	return true, nil
}

// ParseSHCD accepts a machine-readable SHCD and produces an Shcd object, which can be used throughout csi
// It is the golang and csi equivalent of the shcd.json file generated by canu
func ParseSHCD(f []byte) (Shcd, error) {
	var shcd Shcd

	// unmarshall it
	err := json.Unmarshal(f, &shcd)

	if err != nil {
		fmt.Println("error:", err)
		return shcd, err
	}

	return shcd, nil
}

// unNormalizeSemiStandardShcdNonName takes a semi-standard name and returns a normal name
// why is this necessary?
// 1. SHCD.xlsx has their own names
// 2. shcd.json has their own names
// 3. hmn_connections.json has their own names
// 4. other things probably have their own names
// func unNormalizeSemiStandardShcdNonName(s string) string {
// 	var name string
// 	// here begins the mind-blowing algorithm
// 	if strings.HasPrefix(s, "mn") {
// 		// it's a master node, get just the digits
// 		s = strings.TrimPrefix(s, "mn")
// 		// add the non name back in
// 		name = "ncn-m" + s
// 	} else if strings.HasPrefix(s, "wn") {
// 		// it's a worker node
// 		s = strings.TrimPrefix(s, "mn")
// 		name = "ncn-w" + s
// 	} else if strings.HasPrefix(s, "sn") {
// 		// it's a storage node
// 		s = strings.TrimPrefix(s, "sn")
// 		name = "ncn-s" + s
// 	} else if strings.HasPrefix(s, "cn") {
// 		// it's a compute node
// 		s = strings.TrimPrefix(s, "cn")
// 		name = "nid" + s
// 	} else {
// 		name = s
// 	}

// 	return name
// }
