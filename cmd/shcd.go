/*
 *
 *  MIT License
 *
 *  (C) Copyright 2022 Hewlett Packard Enterprise Development LP
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a
 *  copy of this software and associated documentation files (the "Software"),
 *  to deal in the Software without restriction, including without limitation
 *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *  and/or sell copies of the Software, and to permit persons to whom the
 *  Software is furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included
 *  in all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 *  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 *  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 *  OTHER DEALINGS IN THE SOFTWARE.
 *
 */

package cmd

import (
	"encoding/csv"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"sort"
	"strings"
	"unicode"

	// we need a blank import to avoid conflict with go fmt
	// that would remove it
	_ "embed"

	"github.com/Cray-HPE/cray-site-init/pkg/csi"
	"github.com/Cray-HPE/cray-site-init/pkg/shcd"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
	"gopkg.in/yaml.v3"
)

//go:embed embeded-files/shcd-schema.json
var shcdSchemaFile []byte

const (
	hmnConnections        = "hmn_connections.json"
	switchMetadata        = "switch_metadata.csv"
	applicationNodeConfig = "application_node_config.yaml"
	ncnMetadata           = "ncn_metadata.csv"
)

var (
	createANC          bool
	createHMN          bool
	createNCN          bool
	createSM           bool
	customSchema       string
	prefixSubroleMapIn map[string]string
)

// initCmd represents the init command
var shcdCmd = &cobra.Command{
	Use:   "shcd FILEPATH",
	Short: "Generates hmn_connections.json, switch_metadata.csv, and application_node_config.yaml from an SHCD JSON file",
	Long: `Generates hmn_connections.json, switch_metadata.csv, application_node_config.yaml from an SHCD JSON file.

	It accepts only a valid JSON file, generated by 'canu', which is creates a machine-
	readable format understood by csi.  It is checked against a pre-defined schema and
	if it adhere's to it, it generates the necessary seed files.
	`,
	Args: cobra.MinimumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		v := viper.GetViper()
		v.BindPFlags(cmd.Flags())
		shcd, err := shcd.NewShcd(args[0])
		if err != nil {
			log.Fatal(err)
		}
		if v.IsSet("hmn-connections") {
			err := createHMNSeed(shcd.Topology)
			if err != nil {
				fmt.Printf("WARNING - Error creating hmn-connections: %+v", err)
			}
		}
		if v.IsSet("switch-metadata") {
			err := createSwitchSeed(shcd.Topology)
			if err != nil {
				fmt.Printf("WARNING - Error creating switch-metadata: %+v", err)
			}
		}
		if v.IsSet("application-node-config") {
			err := createANCSeed(shcd.Topology)
			if err != nil {
				fmt.Printf("WARNING - Error creating application-node-config: %+v", err)
			}
		}
		if v.IsSet("ncn-metadata") {
			err := createNCNSeed(shcd.Topology)
			if err != nil {
				fmt.Printf("WARNING - Error creating ncn-metadata: %+v", err)
			}
		}
	},
}

func init() {
	shcdCmd.DisableAutoGenTag = true
	shcdCmd.Flags().SortFlags = true
	shcdCmd.Flags().BoolVarP(&createHMN, "hmn-connections", "H", false, "Generate the hmn_connections.json file")
	shcdCmd.Flags().BoolVarP(&createNCN, "ncn-metadata", "N", false, "Generate the ncn_metadata.csv file")
	shcdCmd.Flags().BoolVarP(&createSM, "switch-metadata", "S", false, "Generate the switch_metadata.csv file")
	shcdCmd.Flags().BoolVarP(&createANC, "application-node-config", "A", false, "Generate the application_node_config.yaml file")
	shcdCmd.Flags().StringToStringVarP(&prefixSubroleMapIn, "prefix-subrole-mapping", "M", map[string]string{}, "Specify one or more additional <Prefix>=<Subrole> mappings to use when generating application_node_config.yaml. Multiple mappings can be specified in the format of <prefix1>=<subrole1>,<prefix2>=<subrole2>")
}

// createNCNSeed creates ncn_metadata.csv using information from the shcd
func createNCNSeed(topology []shcd.ID) error {
	var ncns shcd.NCNMetadata
	servers := shcd.FilterByType(topology, "server")
	for _, server := range servers {
		if !strings.HasPrefix(server.CommonName, "ncn") {
			continue
		}
		// Generate the xname based on the rules we predefine
		ncnXname := server.GenerateXname()
		// Do the same for the ncn role and subrole
		ncnRole, ncnSubrole := server.GenerateNCNRoleSubrole()
		// Create a new Switch type and append it to the SwitchMetadata slice
		ncns = append(ncns, shcd.NcnMacs{
			Xname:        ncnXname,
			Role:         ncnRole,
			Subrole:      ncnSubrole,
			BmcMac:       "MAC1",
			BootstrapMac: "MAC2",
			Bond0Mac0:    "MAC3",
			Bond0Mac1:    "MAC4",
		})
	}
	// When writing to csv, the first row should be the headers
	headers := []string{"Xname", "Role", "Subrole", "BMC MAC", "Bootstrap MAC", "Bond0 MAC0", "Bond0 MAC1"}
	// Set up the records we need to write to the file
	// To begin, this contains the headers
	records := [][]string{headers}
	// Then create a new slice with the three pieces of information needed
	for _, v := range ncns {
		row := []string{v.Xname, v.Role, v.Subrole, v.BmcMac, v.BootstrapMac, v.Bond0Mac0, v.Bond0Mac1}
		// Append it to the records slice under the column headers
		records = append(records, row)
	}
	// Create the file object
	ncnmeta, err := os.Create(ncnMetadata)
	if err != nil {
		return err
	}
	defer ncnmeta.Close()
	// Create a writer, which will write the data to the file
	writer := csv.NewWriter(ncnmeta)
	defer writer.Flush()
	// Create a var for all the records except the header
	r := records[1:]
	// Pass an anonymous function to sort.Slice to sort everything except the headers
	sort.Slice(r, func(i, j int) bool {
		return r[i][0] < r[j][0]
	})
	// For each item in the records slice
	for _, v := range records {
		// Write it to the csv file
		if err := writer.Write(v); err != nil {
			return err
		}
	}
	// Let the user know the file was created
	log.Printf("Created %q from SHCD data\n", ncnMetadata)
	return nil
}

// createSwitchSeed creates switch_metadata.csv using information from the shcd
func createSwitchSeed(topology []shcd.ID) error {
	var sws shcd.SwitchMetadata
	switches := shcd.FilterByType(topology, "switch")
	for _, sw := range switches {
		// HSN switch should not be in switch_metadata.csv
		if strings.HasPrefix(sw.CommonName, "sw-hsn") {
			continue
		}
		// Generate the xname based on the rules we predefine
		switchXname := sw.GenerateXname()
		// Do the same for the switch type
		switchType := sw.GenerateSwitchType()
		// The vendor just needs to be capitalized
		switchVendor := strings.Title(sw.Vendor)
		// Create a new Switch type and append it to the SwitchMetadata slice
		sws = append(sws, shcd.Switch{
			Xname: switchXname,
			Type:  switchType,
			Brand: switchVendor,
		})
	}
	// When writing to csv, the first row should be the headers
	headers := []string{"Switch Xname", "Type", "Brand"}
	// Set up the records we need to write to the file
	// To begin, this contains the headers
	records := [][]string{headers}
	// Then create a new slice with the three pieces of information needed
	for _, sw := range sws {
		records = append(records, []string{sw.Xname, sw.Type, sw.Brand})
	}
	// Create the file object
	sm, err := os.Create(switchMetadata)
	if err != nil {
		return err
	}
	defer sm.Close()
	// Create a writer, which will write the data to the file
	writer := csv.NewWriter(sm)
	defer writer.Flush()
	// Create a var for all the records except the header
	r := records[1:]
	sort.Slice(r, func(i, j int) bool {
		return r[i][0] < r[j][0]
	})
	// For each item in the records slice
	for _, r := range records {
		// Write it to the csv file
		if err := writer.Write(r); err != nil {
			return err
		}
	}

	// Let the user know the file was created
	log.Printf("Created %q from SHCD data\n", switchMetadata)
	return nil
}

// createHMNSeed creates hmn_connections.json using information from the shcd
func createHMNSeed(topology []shcd.ID) error {
	var hmn shcd.HMNConnections
	for i := range topology {
		// instantiate a new HMNComponent
		hmnConnection := shcd.HMNComponent{}
		// This just aligns the names to better match existing hmn_connections.json's
		// The SHCD and shcd.json all use different names, so why should csi be any different?
		// nodeName := unNormalizeSemiStandardShcdNonName(topology[i].CommonName)
		// Setting the source name, source rack, source location, is pretty straightforward here
		hmnConnection.Source = topology[i].GenerateSourceName()
		hmnConnection.SourceRack = topology[i].Location.Rack
		hmnConnection.SourceLocation = topology[i].Location.Elevation
		// Now it starts to get more complex.
		// shcd.json has an array of ports that the device is connected to
		// loop through the ports and find the destination id, which can be used
		// to find the destination info
		for p := range topology[i].Ports {
			// get the id of the destination node, so it can be easily used an an index
			destID := topology[i].Ports[p].DestNodeID
			// Special to this hmn_connections.json file, we need this SubRack/dense node stuff
			// if the node is a dense compute node--indiciated by L or R in the location,
			// we need to add the SourceSubLocation and SourceParent
			// There should be a row in the shcd that has the SubRack name, which
			// shares the same u location as the entries with the L or R in the location
			if strings.HasSuffix(topology[i].Location.Elevation, "L") || strings.HasSuffix(topology[i].Location.Elevation, "R") {
				// hmnConnection.SourceSubLocation = shcd[i].Location.Rack
				hmnConnection.SourceParent = "FIXME INSERT SUBRACK HERE"
				// FIXME: remove above and uncomment below when we have a way to get the subrack name
				// hmnConnection.SourceParent = fmt.Sprint(shcd[destID].CommonName)
			}
			// Now use the destID again to set the destination info
			hmnConnection.DestinationRack = topology[destID].Location.Rack
			hmnConnection.DestinationLocation = topology[destID].Location.Elevation
			hmnConnection.DestinationPort = fmt.Sprint("j", topology[i].Ports[p].DestPort)
		}
		// finally, append the created HMNComponent to the HMNConnections slice
		// This slice will be what is written to the file as hmn_connections.json
		hmn = append(hmn, hmnConnection)
	}
	// Indent the file for better human-readability
	file, err := json.MarshalIndent(hmn, "", "    ")
	if err != nil {
		return err
	}
	// Write the file to disk
	err = ioutil.WriteFile(hmnConnections, file, 0644)
	if err != nil {
		return err
	}
	log.Printf("Created %q from SHCD data\n", hmnConnections)
	return nil
}

// createANCSeed creates application_node_config.yaml using information from the shcd
func createANCSeed(topology []shcd.ID) error {
	var (
		comment1 string = "# Additional application node prefixes to match in the hmn_connections.json file"
		comment2 string = "\n# Additional HSM SubRoles"
		comment3 string = "\n# Application Node aliases"
	)
	anc := csi.SLSGeneratorApplicationNodeConfig{
		Prefixes:          make([]string, 0, 1),
		PrefixHSMSubroles: make(map[string]string),
		Aliases:           make(map[string][]string),
	}
	// Search the shcd for Application Nodes
	servers := shcd.FilterByType(topology, "server")
	for _, server := range servers {
		if strings.Contains(server.CommonName, "ncn") {
			continue
		}
		source := server.GenerateSourceName()
		location := strings.TrimFunc(server.Location.Elevation,
			func(r rune) bool { return unicode.IsLetter(r) })
		xname := ""
		if strings.HasSuffix(strings.ToLower(server.Location.Elevation), "l") {
			xname = fmt.Sprintf("%sc0s%sb1n0", server.Location.Rack, location)
		} else if strings.HasSuffix(strings.ToLower(server.Location.Elevation), "r") {
			xname = fmt.Sprintf("%sc0s%sb2n0", server.Location.Rack, location)
		} else {
			xname = fmt.Sprintf("%sc0s%sb0n0", server.Location.Rack, location)
		}
		if _, ok := anc.Aliases[xname]; !ok {
			anc.Aliases[xname] = make([]string, 0, 1)
		}
		anc.Aliases[xname] = append(anc.Aliases[xname], source)
	}
	shcdPrefixes := shcd.Prefixes(topology)
	for _, prefix := range shcdPrefixes {
		anc.Prefixes = append(anc.Prefixes, prefix)
		subrole, ok := csi.DefaultApplicationNodeSubroles[prefix]
		if !ok {
			subrole = csi.SubrolePlaceHolder
			log.Printf("WARNING: Prefix '%s' has no subrole mapping. Replace `%s` placeholder with a valid subrole in the resulting %s.\n", prefix, csi.SubrolePlaceHolder, applicationNodeConfig)
		}
		anc.PrefixHSMSubroles[prefix] = subrole
	}
	// Format the yaml
	prefixNodes := []*yaml.Node{}
	prefixHSMSubroleNodes := []*yaml.Node{}
	for _, prefix := range anc.Prefixes {
		n := yaml.Node{Kind: yaml.ScalarNode, Value: prefix}
		prefixNodes = append(prefixNodes, &n)
		subrole := anc.PrefixHSMSubroles[prefix]
		kn := yaml.Node{Kind: yaml.ScalarNode, Value: prefix}
		vn := yaml.Node{Kind: yaml.ScalarNode, Value: subrole}
		prefixHSMSubroleNodes = append(prefixHSMSubroleNodes, &kn, &vn)
	}
	prefixes := yaml.Node{Kind: yaml.SequenceNode, Content: prefixNodes}
	prefixesTitle := yaml.Node{Kind: yaml.ScalarNode, Value: "prefixes", HeadComment: comment1}
	prefixHSMSubroles := yaml.Node{Kind: yaml.MappingNode, Content: prefixHSMSubroleNodes}
	prefixHSMSubrolesTitle := yaml.Node{Kind: yaml.ScalarNode, Value: "prefix_hsm_subroles", HeadComment: comment2}
	aliasNodes := []*yaml.Node{}
	aliasArray := make([]string, 0, 1)
	for xname := range anc.Aliases {
		aliasArray = append(aliasArray, xname)
	}
	sort.Strings(aliasArray)
	for _, xname := range aliasArray {
		aliasList := anc.Aliases[xname]
		kn := yaml.Node{Kind: yaml.ScalarNode, Value: xname}
		aliasSubNodes := []*yaml.Node{}
		for _, alias := range aliasList {
			n := yaml.Node{Kind: yaml.ScalarNode, Style: yaml.DoubleQuotedStyle, Value: alias}
			aliasSubNodes = append(aliasSubNodes, &n)
		}
		vn := yaml.Node{Kind: yaml.SequenceNode, Style: yaml.FlowStyle, Content: aliasSubNodes}
		aliasNodes = append(aliasNodes, &kn, &vn)
	}
	aliases := yaml.Node{Kind: yaml.MappingNode, Content: aliasNodes}
	aliasesTitle := yaml.Node{Kind: yaml.ScalarNode, Value: "aliases", HeadComment: comment3}
	ancYaml := yaml.Node{Kind: yaml.MappingNode, Content: []*yaml.Node{&prefixesTitle, &prefixes, &prefixHSMSubrolesTitle, &prefixHSMSubroles, &aliasesTitle, &aliases}}
	ancFile, err := os.Create(applicationNodeConfig)
	if err != nil {
		return err
	}
	defer ancFile.Close()
	_, err = ancFile.WriteString("---\n")
	if err != nil {
		return err
	}
	e := yaml.NewEncoder(ancFile)
	defer e.Close()
	e.SetIndent(4)
	err = e.Encode(ancYaml)
	if err != nil {
		return err
	}
	log.Printf("Created %q from SHCD data\n", applicationNodeConfig)
	return nil
}
